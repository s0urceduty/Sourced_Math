<img width="1280" height="640" alt="Math" src="https://github.com/user-attachments/assets/610a9987-1c93-4f4e-a3fb-77d89aeabd67" />

Sourced Math is a comprehensive computational mathematics library that unifies all 114 Sourceduty frameworks into a structured, modular Python ecosystem. The library is designed to operate across logical systems, signal processing, optimization theory, forecasting models, quantum computation, adaptive control systems, and multi-domain simulations. At its core, Sourced Math integrates symbolic reasoning (e.g., Truthvar, OpLog, Optimation_Theorem), numerical modeling (e.g., Quadexpo, Inversonic, Radicant), and structural transformations (e.g., Transmute_T, PreJunc, Abstract_Away) into a single interoperable architecture. This allows users to move seamlessly between algebraic manipulation, probabilistic modeling, dynamic simulations, and constraint-based optimization without leaving the framework. The inclusion of hybrid models such as explogint, Fractal_Function, and Oscillant_Function enables nonlinear, oscillatory, and asymptotic systems to be represented with high expressive flexibility. Additionally, built-in sensitivity analysis (SensVar), impact quantification (ImpactQ, Info_Impact), and computational evaluation (Computation_Percent, Complex_Forecast) allow users to measure not only results, but also performance and structural influence.

Beyond pure mathematics, Sourced Math extends into real-time adaptive systems and intelligent computation. Functions such as RealResp, Q_Neuron, and Quantum_Gradient_Descent enable neural and quantum-inspired learning processes, while Navisol, Linear_Matrix_Signal, and Signal_Optimate support robotic navigation and signal optimization. Resource allocation and fairness modeling are handled through frameworks like Modbias, DistribuTar, and Weighted_State, ensuring ethical and efficient optimization across competing domains. The library is built around the principle of universal orchestration (Universal_Organization), meaning that any function can be nested, chained, or coordinated within larger workflows. As a result, Sourced Math functions not merely as a collection of mathematical utilities, but as a scalable computational engine capable of modeling logical systems, physical processes, abstract structures, and adaptive intelligent environments within a unified mathematical language.

Functions:
------------

#### ARITHMETIC AND ALGEBRAIC FOUNDATIONS
1. `Add_A(x, y)`: Performs the summation of two numerical inputs within a defined algebraic field.
2. `Subtract_A(x, y)`: Computes the difference between two values, often used to determine relative distance.
3. `Multiply_A(x, y)`: Executes scalar or vector multiplication depending on the input space.
4. `Divide_A(x, y)`: Calculates the quotient of two values, handling zero-division exceptions.
5. `Modulo_A(x, n)`: Returns the remainder after division, essential for periodic calculations.
6. `Power_P(x, n)`: Raises a base value to a specified exponent for growth modeling.
7. `Root_R(x, n)`: Extracts the n-th root of a value, the inverse operation of exponentiation.
8. `Factorial_F(n)`: Computes the product of all positive integers up to n, vital for combinatorics.
9. `Absolute_V(x)`: Returns the non-negative magnitude of a value regardless of its sign.
10. `Floor_F(x)`: Maps a real number to the largest previous integer.
11. `Ceiling_C(x)`: Maps a real number to the smallest subsequent integer.
12. `Round_R(x, d)`: Approximates a numerical value to a specified number of decimal places.
13. `Reciprocal_R(x)`: Returns the multiplicative inverse of the input value.
14. `Sign_S(x)`: Identifies the polarity of a number, returning -1, 0, or 1.
15. `Mean_M(v)`: Computes the arithmetic average of a given dataset.
16. `Median_M(v)`: Identifies the middle value in a sorted numerical sequence.
17. `Variance_V(v)`: Measures the spread of numbers in a dataset relative to the mean.
18. `Deviation_S(v)`: Calculates the standard deviation to quantify data dispersion.
19. `Permutation_P(n, k)`: Calculates the number of ways to arrange k items from n.
20. `Combination_C(n, k)`: Determines the number of ways to select k items from n without regard to order.

#### TRIGONOMETRIC AND CIRCULAR FUNCTIONS
21. `Sine_S(θ)`: Returns the vertical coordinate of a point on a unit circle at angle θ.
22. `Cosine_C(θ)`: Returns the horizontal coordinate of a point on a unit circle at angle θ.
23. `Tangent_T(θ)`: Computes the ratio of sine to cosine, representing a slope.
24. `Secant_S(θ)`: Returns the reciprocal of the cosine function.
25. `Cosecant_C(θ)`: Returns the reciprocal of the sine function.
26. `Cotangent_C(θ)`: Returns the reciprocal of the tangent function.
27. `ArcSine_A(x)`: The inverse sine function, returning the angle for a given ratio.
28. `ArcCosine_A(x)`: The inverse cosine function, determining the angle for a given x-coordinate.
29. `ArcTangent_A(x)`: The inverse tangent function, identifying the angle of a slope.
30. `HyperbolicSine_H(x)`: Models growth and decay patterns via the (e^x - e^-x)/2 formula.
31. `HyperbolicCosine_H(x)`: Represents the shape of a hanging cable (catenary).
32. `HyperbolicTangent_H(x)`: Used frequently in neural network activation layers.
33. `DegreesToRadians_C(d)`: Converts angular measurements from degrees to the radian system.
34. `RadiansToDegrees_C(r)`: Converts radial measurements back into standard degrees.

#### LOGARITHMIC AND EXPONENTIAL SYSTEMS
35. `Exp_E(x)`: Calculates the constant e raised to the power of x.
36. `LogNatural_L(x)`: Computes the logarithm with base e, common in calculus.
37. `LogBase10_L(x)`: Determines the exponent needed to produce a value using base 10.
38. `LogBase2_L(x)`: Calculates bit-depth requirements and binary complexity.
39. `LogBaseN_L(x, n)`: A generalized logarithm function for any positive base n.
40. `Logistic_L(x)`: Maps any real-valued number into a range between 0 and 1.
41. `Softmax_S(v)`: Normalizes a vector into a probability distribution.

#### VECTOR AND MATRIX OPERATIONS
42. `DotProduct_V(a, b)`: Calculates the scalar product of two vectors to find alignment.
43. `CrossProduct_V(a, b)`: Produces a third vector perpendicular to the original pair.
44. `Magnitude_V(v)`: Computes the Euclidean length of a vector in n-dimensional space.
45. `Normalize_V(v)`: Scales a vector to a magnitude of 1 while keeping its direction.
46. `Transpose_M(m)`: Flips a matrix over its diagonal, switching rows and columns.
47. `Determinant_M(m)`: Provides a scalar value reflecting the scaling factor of a matrix.
48. `Inverse_M(m)`: Finds the matrix that, when multiplied by the original, yields identity.
49. `Trace_M(m)`: Sums the elements on the main diagonal of a square matrix.
50. `EigenValues_E(m)`: Extracts scalars associated with linear transformations.
51. `EigenVectors_E(m)`: Identifies the directions that remain unchanged during transformation.

#### CALCULUS AND NUMERICAL ANALYSIS
52. `Derivative_D(f, x)`: Estimates the instantaneous rate of change of a function at x.
53. `Integral_I(f, a, b)`: Computes the area under a curve between two bounds.
54. `Gradient_G(f, v)`: Returns a vector of partial derivatives for multivariable functions.
55. `Hessian_H(f, v)`: Calculates the square matrix of second-order partial derivatives.
56. `Jacobian_J(f, v)`: Represents the best linear approximation of a differentiable map.
57. `Laplacian_L(f)`: Measures the divergence of the gradient of a scalar field.
58. `TaylorSeries_T(f, n)`: Approximates a function using an infinite sum of derivatives.
59. `NewtonRaphson_N(f, x)`: Iteratively finds the roots of a real-valued function.

#### LOGIC AND SET THEORY
60. `Union_S(a, b)`: Combines all unique elements from two distinct sets.
61. `Intersection_I(a, b)`: Identifies elements common to both input sets.
62. `Difference_D(a, b)`: Returns elements present in set A but not in set B.
63. `Complement_C(a, u)`: Finds elements in the universal set not present in set A.
64. `PowerSet_P(s)`: Generates all possible subsets of a given set.
65. `CartesianProduct_C(a, b)`: Creates a set of all ordered pairs from two sets.
66. `LogicalAND_L(p, q)`: Returns true only if both propositions are true.
67. `LogicalOR_L(p, q)`: Returns true if at least one proposition is true.
68. `LogicalXOR_L(p, q)`: Returns true only if the inputs differ.
69. `LogicalNOT_L(p)`: Reverses the truth value of a proposition.

#### STATISTICAL DISTRIBUTIONS AND PROBABILITY
70. `NormalPDF_N(x, μ, σ)`: Calculates the probability density of the Gaussian distribution.
71. `NormalCDF_N(x, μ, σ)`: Determines the cumulative probability for a normal variable.
72. `Binomial_B(n, p, k)`: Computes the probability of exactly k successes in n trials.
73. `Poisson_P(λ, k)`: Models the probability of events occurring in a fixed interval.
74. `Bayes_B(a, b)`: Updates the probability of a hypothesis based on new evidence.
75. `Correlation_C(x, y)`: Measures the linear relationship between two variables.
76. `RegressionLinear_R(x, y)`: Fits a straight line to a set of data points.

#### COMPLEX NUMBERS AND SIGNAL PROCESSING
77. `ComplexAdd_C(z1, z2)`: Sums the real and imaginary parts of complex numbers.
78. `Conjugate_C(z)`: Flips the sign of the imaginary component of a complex number.
79. `FourierTransform_F(v)`: Converts a time-domain signal into its frequency components.
80. `InverseFourier_F(v)`: Reconstructs a signal from its frequency domain.
81. `Magnitude_C(z)`: Finds the distance from the origin in the complex plane.
82. `Phase_P(z)`: Determines the angle of a complex number relative to the real axis.

#### SPECIAL MATHEMATICAL TRANSFORMS
83. `Transmute_T(x)`: This function transforms input values into alternative mathematical forms while preserving their essential structural properties.
84. `LaplaceTransform_L(f)`: Converts differential equations into easier algebraic forms.
85. `ZTransform_Z(v)`: The discrete-time equivalent of the Laplace transform.
86. `WaveletTransform_W(v)`: Analyzes signals at different scales or resolutions.
87. `Sigmoid_S(x)`: A specific S-shaped curve used to map values to a range.
88. `ReLU_R(x)`: A Rectified Linear Unit function that returns zero for negative inputs.

#### DISCRETE MATH AND NUMBER THEORY
89. `GCD_G(a, b)`: Finds the greatest common divisor between two integers.
90. `LCM_L(a, b)`: Identifies the least common multiple of two integers.
91. `IsPrime_P(n)`: Evaluates whether a number has exactly two distinct divisors.
92. `PrimesToN_P(n)`: Generates a list of all prime numbers up to value n.
93. `Totient_T(n)`: Counts the positive integers up to n that are relatively prime to n.
94. `Fibonacci_F(n)`: Computes the n-th value in the integer sequence.
95. `Collatz_C(n)`: Applies the 3n+1 algorithm to evaluate sequence convergence.
96. `ModInverse_M(a, n)`: Finds the modular multiplicative inverse of an integer.

#### GEOMETRIC AND TOPOLOGICAL UTILITIES
97. `EuclideanDistance_D(p1, p2)`: Calculates the straight-line distance between two points.
98. `ManhattanDistance_D(p1, p2)`: Measures distance along axes at right angles.
99. `ChebyshevDistance_D(p1, p2)`: Determines the maximum coordinate difference between points.
100. `AreaTriangle_A(a, b, c)`: Calculates area using Heron’s formula.
101. `VolumeSphere_V(r)`: Computes the three-dimensional space enclosed by a sphere.
102. `PerimeterCircle_P(r)`: Returns the circumference of a circle given its radius.
103. `Centroid_C(points)`: Finds the geometric center of a polygon.

#### ADVANCED OPERATIONAL LOGIC
104. `Map_M(v, f)`: Applies a specific function to every element in a list.
105. `Filter_F(v, p)`: Selects elements from a dataset based on a predicate.
106. `Reduce_R(v, f)`: Condenses a list into a single value using an accumulator.
107. `Compose_C(f, g)`: Joins two functions such that the output of one is the input of the other.
108. `Curry_C(f)`: Breaks down a multi-argument function into a sequence of unary functions.
109. `Memoize_M(f)`: Stores results of expensive function calls for reuse.
110. `Pipeline_P(v, functions)`: Passes data through a sequence of operations.
111. `Clamp_C(x, min, max)`: Restricts a value to a specified numerical range.
112. `InterpolateLinear_I(a, b, t)`: Estimates values between two points linearly.
113. `SmoothStep_S(t)`: Provides a smooth transition between 0 and 1.
114. `NoisePerlin_N(x, y)`: Generates gradient noise for procedural textures.

Prototype Lib
------------

Sourced Math is currently positioned as a prototype PyPI library designed to unify the full suite of 114 Sourceduty mathematical frameworks into a distributable, installable Python package for research, experimentation, and advanced systems modeling. As a prototype, it serves as a foundational release that demonstrates architectural cohesion, modular function interoperability, and extensible design rather than final production-level optimization. The package is structured to support scalable namespace organization (e.g., sourcedmath.optimization, sourcedmath.signal, sourcedmath.logic, sourcedmath.quantum, sourcedmath.simulation), allowing users to selectively import frameworks or integrate the entire computational ecosystem into larger analytical pipelines. In this early-stage release, emphasis is placed on API consistency, mathematical correctness, and cross-function chaining capabilities—enabling developers, mathematicians, and systems engineers to experiment with hybrid models such as quantum-gradient optimization combined with adaptive signal weighting or fairness-aware allocation layered over dynamic growth forecasting. Documentation includes structured docstrings, LaTeX-rendered equations for formal definitions, and prototype examples demonstrating workflow orchestration across multiple function classes. While performance benchmarking, compiled acceleration layers, and large-scale distributed execution remain areas for future development, this prototype PyPI version establishes Sourced Math as a unified mathematical engine framework, offering a novel blend of symbolic logic, nonlinear modeling, optimization theory, and adaptive computation within a single installable Python environment.

------------
https://chatgpt.com/g/g-67cc981656b8819196c22b67c9fbbb8c-sourceduty-math
<br>
https://sourceduty.com/
